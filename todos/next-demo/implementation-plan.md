# Implementation Plan: next-demo

## Overview

The demo system has five parts: artifact storage with numbered folders, a command that captures data and generates render scripts, semver gating for compatibility, orchestration wiring that triggers it, and docs that formalize it. The command is the core — it reads from todo artifacts and git, writes a snapshot + render script, presents via widget, and commits the result.

---

## Phase 1: Artifact Storage & Format

### Task 1.1: Create `demos/` directory and format spec

**File(s):** `demos/.gitkeep`, `docs/project/spec/demo-artifact.md`

- [x] Create `demos/` directory at repository root
- [x] Write a doc snippet (`project/spec/demo-artifact`) defining:
  - Numbered folder convention: `NNN-{slug}/` (zero-padded sequence)
  - `snapshot.json` schema: slug, title, sequence, version, delivered date, commit hash, metrics object, acts object (challenge, build, gauntlet, whats_next)
  - `demo.sh` contract: reads snapshot, checks semver, renders or exits
- [x] Sequence number derived from count of existing `demos/*/` folders + 1

---

## Phase 2: `/next-demo` Command

### Task 2.1: Create the command artifact

**File(s):** `agents/commands/next-demo.md`

- [x] Create `/next-demo` command following the agent artifact schema
- [x] Required reads: `software-development/procedure/lifecycle/demo`, `project/spec/demo-artifact`
- [x] Input: slug (from `$ARGUMENTS`)
- [x] Steps:
  1. Determine sequence number from existing `demos/*/` folders
  2. Read todo artifacts: `requirements.md`, `implementation-plan.md`, `review-findings.md`, `quality-checklist.md`, `state.json`
  3. Run git commands for metrics: `git log --oneline main..{slug}` for commit count, `git diff --stat main..{slug}` for file/line stats, `git diff --diff-filter=A --name-only main..{slug}` for new files
  4. Read `todos/delivered.md` for title and date
  5. Read project version from `pyproject.toml`
  6. Compose `snapshot.json` with all captured data including the five acts
  7. Generate `demo.sh` render script with semver gate
  8. Write both files to `demos/{NNN}-{slug}/`
  9. Render via `teleclaude__render_widget` with success status, five sections, metrics table
  10. Commit the demo folder
- [x] Output format: `DEMO COMPLETE: {slug}\nArtifact: demos/{NNN}-{slug}/\nWidget: rendered`

### Task 2.2: Tone and content guidance in the command

**File(s):** `agents/commands/next-demo.md`

- [x] Act 1 (Challenge): One paragraph, no jargon, user's perspective. Source: `requirements.md` Goal section.
- [x] Act 2 (Build): The most interesting technical choice. Source: `implementation-plan.md` overview + git diff stat.
- [x] Act 3 (Gauntlet): Quality earned, not rework endured. Source: `review-findings.md` — criticals found/fixed, rounds survived.
- [x] Act 4 (Numbers): Metrics table, scannable at a glance. Source: git + state.json.
- [x] Act 5 (What's Next): Non-blocking suggestions from review findings. Ideas for future work.
- [x] Tone: celebratory but specific. Let the numbers speak. No fluff.

### Task 2.3: Generate `demo.sh` render script

**File(s):** `agents/commands/next-demo.md` (script generation logic)

- [x] `demo.sh` is generated by the command, not a static template
- [x] Script reads `snapshot.json` from its own directory (`$(dirname "$0")/snapshot.json`)
- [x] Extracts `version` field, compares major component against current `pyproject.toml` version
- [x] If major mismatch: prints compatibility message and exits 0 (no error, just skipped)
- [x] If compatible: renders the demo via curl to the daemon API (`render_widget` endpoint) or falls back to formatted terminal output (jq + printf)
- [x] Script is `chmod +x`

---

## Phase 3: Orchestration Wiring

### Task 3.1: Update finalize completion handler template

**File(s):** `teleclaude/core/next_machine/core.py`

The demo step lives in the `"next-finalize"` completion instructions template (`COMPLETION_INSTRUCTIONS` dict, ~line 143). Insert the demo dispatch between "end session" and "CLEANUP":

- [x] In the `"next-finalize"` template, insert a DEMO step:
  ```
  WHEN WORKER COMPLETES:
  1. Verify merge succeeded and delivery log updated
  2. If success:
     - teleclaude__end_session(...)
     - DEMO (run before cleanup, while artifacts exist):
       teleclaude__run_agent_command(command="/next-demo", args="{slug}", ...)
       Wait for demo to complete. If it fails, log warning and continue.
     - CLEANUP (orchestrator-owned, run from main repo):
       ...
  ```
- [x] Add `"next-demo"` to `COMPLETION_INSTRUCTIONS` with a simple handler (demo has no post-completion orchestration — the next call is already wired from finalize's handler)
- [x] The demo step is non-blocking: if it fails, log a warning and proceed to cleanup

---

## Phase 4: Documentation Updates

### Task 4.1: Update demo procedure doc — artifact storage

**File(s):** `docs/global/software-development/procedure/lifecycle/demo.md`

- [x] Replace step 4 (Archive) with:
  - Determine sequence number, create `demos/{NNN}-{slug}/`
  - Write `snapshot.json` with captured data and current project version
  - Generate `demo.sh` render script with semver gate
  - Commit the demo folder before cleanup removes the source data
- [x] Add version gating to the procedure: render scripts check semver compatibility before executing

### Task 4.2: Update lifecycle overview — add Demo phase

**File(s):** `docs/global/software-development/procedure/lifecycle-overview.md`

- [x] Add Demo as phase 6 between Finalize and Maintenance:
  ```
  1. Prepare
  2. Build
  3. Review
  4. Fix
  5. Finalize
  6. Demo
  7. Maintenance
  ```
- [x] Add a section describing the Demo phase: output is `demos/{NNN}-{slug}/`, responsibility is Orchestrator, triggered automatically after finalize, gated by semver at render time

### Task 4.3: Sync index after doc changes

**File(s):** `docs/global/index.yaml`

- [x] Run `telec sync` to update the snippet index with any new or modified docs

---

## Phase 5: Widget Rendering

### Task 5.1: Demo widget composition logic

**File(s):** `agents/commands/next-demo.md` (rendering section)

- [x] Define the `render_widget` expression structure:
  - `title`: "{title}"
  - `status`: "success"
  - `sections`:
    - `text` section for each act (Acts 1–3, 5)
    - `table` section for Act 4 (metrics)
    - `divider` between acts
    - `code` section if a specific technical decision deserves highlighting
  - `footer`: merge commit hash + delivery date + version
- [x] Widget rendered to the orchestrator's session
- [x] The `snapshot.json` + `demo.sh` in `demos/` is the durable version; the widget is the live presentation

---

## Phase 6: Validation

### Task 6.1: Tests

- [x] Test that demo artifact structure matches the spec (folder with `snapshot.json` + `demo.sh`)
- [x] Test `snapshot.json` schema: required fields present, types correct
- [x] Test `demo.sh` semver gate: exits cleanly on major mismatch, runs on match
- [x] Test that the state machine includes the demo step after finalize
- [x] Test graceful degradation: demo failure does not block cleanup
- [x] Run `make test`

### Task 6.2: Quality Checks

- [x] Run `make lint`
- [x] Verify no unchecked implementation tasks remain
- [x] Verify demo procedure doc and lifecycle overview are consistent

---

## Phase 7: Review Readiness

- [x] Confirm requirements are reflected in code changes
- [x] Confirm implementation tasks are all marked `[x]`
- [x] Document any deferrals explicitly
