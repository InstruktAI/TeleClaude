---
id: 'software-development/procedure/lifecycle/demo'
type: 'procedure'
domain: 'software-development'
scope: 'project'
description: 'Create demo.md artifacts during build and present them to celebrate delivery.'
---

# Demo — Procedure

## Goal

Celebrate every delivery with a runnable demonstration of what was built. The demo is the ultimate functional test — if it can't be demonstrated, it's not delivered.

## The demo.md artifact

`demo.md` is a freeform markdown file with steps for the AI presenter to execute. It contains:

- **Executable code blocks** (` ```bash `) — extracted and run by `telec todo demo` for automated validation. This is the demo validator and build gate.
- **Guided steps** — instructions for the AI to operate the system (TUI keypresses, Playwright actions, CLI commands, API calls) and narrate to the user.
- **Verification steps** — assertions the AI checks ("output should contain X", "user should see Y").

### Testability is the default

Almost everything should be testable via code blocks. The AI can spin up its own TUI instance (no singleton constraint), run Playwright for web UI, start sessions, call APIs. "Not automatable" should be the rare exception — annotated with `<!-- skip-validation: reason -->` on the code block — not the default.

Even TUI demos should have testable blocks: the AI runs its own `telec` instance, sends keys, verifies state. The guided presentation to the user is a separate concern from validation — validation proves it works, presentation shows it off.

### Non-destructive by default

Demos run on real data. They must never be destructive. If the demo needs to exercise CRUD operations, it creates its own test data, demonstrates the behavior, and cleans up after itself. The builder writes the demo with this awareness: you're running on a live system.

Exception: demos may modify data they created themselves within the demo scope. The cleanup is part of the demo steps.

### Heuristics (not prescriptive)

- CLI change: run the command, verify output
- TUI change: spin up own TUI instance and operate it
- Web UI: drive Playwright
- Messaging: trigger via API
- Bug fix: reproduce the scenario that was broken, show it works now

## Creation lifecycle

### Prepare phase (Architect)

The architect drafts `demo.md` during preparation. The draft defines:

- What medium is the delivery shown in? (CLI, TUI, web, API)
- What does the user observe?
- What commands validate it works?

The draft doesn't need to be perfect — the builder refines it with real implementation knowledge.

### Build phase (Builder)

The builder refines `demo.md` with working executable blocks. Demo validation is a build gate:

1. Run `telec todo demo validate {slug}` — confirms executable blocks exist.
   (The builder works in a worktree — only structural validation is possible here.
   Actual execution happens on main after merge.)
2. If validation fails, the build is not done. Fix forward.
3. Create `demos/{slug}/` folder with `demo.md` (copy from `todos/{slug}/demo.md`).
   (`snapshot.json` is generated by the orchestrator after merge.)

### Escape hatch

Individual code blocks can be annotated `<!-- skip-validation: reason -->` when they genuinely can't be run by the CLI validator (e.g., requires human visual confirmation). This should be rare.

If an entire delivery can't produce any executable demo steps (pure refactors with no observable behavior change), the builder notes the exception in `demo.md` with reasoning, and the reviewer accepts or pushes back.

### Bug fixes get demos too

A bug fix demo is often the simplest: reproduce the scenario that was broken, show it works now. "The bug is gone" is an assertion. The demo is the proof.

## snapshot.json

The five acts narrative lives in `snapshot.json` — that's the delivery story:

1. **The Challenge** — what problem this solved
2. **The Build** — key architectural decisions
3. **The Gauntlet** — review rounds survived
4. **The Numbers** — metrics (rendered from the metrics object)
5. **What's Next** — ideas sparked, what this unlocks

See `project/spec/demo-artifact` for the full schema.

## Presentation

### Conversational presentation (/next-demo)

- **No slug:** AI lists available demos and asks which to present.
- **With slug:** AI reads `demos/{slug}/demo.md` and walks through all steps — executing code blocks, operating the system for guided steps, checking verification assertions. After a successful walkthrough, celebrates with the five acts narrative from `snapshot.json`.

### CLI commands (telec todo demo)

- **No args:** lists all available demos (table format: slug, title, version, delivered date).
- **`validate {slug}`:** structural check — confirms executable bash blocks exist. Used during build (worktree-safe).
- **`run {slug}`:** executes bash blocks sequentially. All must exit 0. Used on main after merge. Falls back to `snapshot.json` `demo` field for backward compatibility.
- **`create {slug}`:** promotes `todos/{slug}/demo.md` to `demos/{slug}/demo.md`.

## Recovery

- Demos survive cleanup (they live in `demos/{slug}/`, not `todos/{slug}/`).
- If a demo is missing `demo.md`, the runner falls back to the `snapshot.json` `demo` field (backward compatibility).
- Breaking major version bumps disable stale demos automatically via semver gate.
